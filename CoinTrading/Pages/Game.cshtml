@page
@model CoinTrading.Pages.GameModel
@{
    ViewData["Title"] = "Live Coin Price";
}

<style>
    .trade-form {
        display: flex;
        align-items: flex-end;
        justify-content: center;
        margin-top: 20px;

    }

    .trade-form .form-group {
        margin: 0 10px;
        flex: 1;
    }


    .trade-form .form-group input,
    .trade-form .form-group select {
        width: 100%; /* Modifierad till 100% för att ta upp hela bredden av .form-group */
        margin: auto;
                background-color: #686968;
                color: white;
    }

    .trade-form .buysell-buttons {
        display: flex;
        align-items: flex-end;
        padding: 10px;
        
    }

    #myHoverPrice {
        position: absolute;
    }

    input[type="text"], textarea, select {
        background-color: #686968;
        color: white;
    }

    .stats {
        display: flex;
        justify-content: space-around;
       
        margin-bottom: 20px;
        color: white;
        font-size: 1.2em;
    }

    #lineChart {
        border: 1px solid #000;
        background-image: url('Images/graphbg.png');
        background-color: #0D2738;
        background-size: cover;
    }
    .game
    {
     width: 1200px;
        background-color: #333333;
     padding-bottom: 20px;
     padding-top: 20px;
    }
</style>
<div class="game">
<div class="text-center">
    @* <h1 id="priceText" class="display-4">Live Coin Price</h1> *@
   
    @Html.Raw(HttpContext.Session.GetAlert())

    <!-- Eriks ändringar -->
    <div id="myHoverPrice"></div>
    <!-- slut på Eriks ändringar -->
    <!--amirs ändringar-->
    <div class="stats">
        <div id="balance">Balance: $0.00</div>
        <div id="entryPrice">Average Entry Price: $0.00</div>
        <div id="orderValue">Order Value: $0.00</div>
        <div id="pl">P&L: $0.00</div>
    </div>
    <!--slut på amirs ändringar-->
    <canvas id="lineChart" width="1200" height="800" style="border:1px solid #000; background-color: #0D2738;"></canvas>
    @if (Model.IsLoegin)
    {
        <div class="trade-form">
            <div class="form-group">
                <label for="marketType">Order Type</label>
                <select id="marketType" name="marketType" class="form-control">
                    <option value="market">Market</option>
                    <option value="limit">Limit</option>
                </select>
            </div>
            <div class="form-group">
                <label for="leverage">Leverage</label>
                <select id="leverage" name="leverage" class="form-control">
                    @for (int i = 1; i <= 100; i++)
                    {
                        @if (i == 10)
                        {
                            <option selected>@i</option>
                        }
                        else
                        {
                            <option>@i</option>
                        }
                    }
                </select>
            </div>
            <div class="form-group">
                <label for="price">Price</label>
                <input type="number" step="0.01" id="price" name="price" class="form-control" placeholder="Price">
            </div>
            <div class="form-group">
                <label for="amount">Amount</label> <small id="total-value"></small>
                <input type="text" id="amount" name="amount" class="form-control" placeholder="Amount">
                <small id="orderValue"></small>
            </div>
            <div class="buysell-buttons">
                <button class="btn btn-primary buy-sell-btn">Buy</button>
                <button class="btn btn-danger buy-sell-btn">Sell</button>
            </div>
        </div>
    }
    else
    {
        <div><a href="./Login">Login</a></div>
    }

</div>
</div>
@section Scripts {
    <script>

        document.addEventListener("DOMContentLoaded", function () { // detta event kan städas bort
            const canvas = document.getElementById('lineChart');
            const ctx = canvas.getContext('2d');

            const width = canvas.width;
            const height = canvas.height;
            const graphWidth = width;
            const graphHeight = height;
            let lastMouseY = 0;
            let lastMouseX = 0;
            let currentPrice = 0;
            let labels = [];
            let data = [];

            let zoomOutAxisY = 0.75;
            let graphMinY = 0;
            let graphMaxY = 1;
            let isMouseOnChart = false;
            let myPrice = 0;

            const maxDataPoints = 300; // Assuming 1 data point per second for 5 minutes


            // first load in old stored data to catch up
            const init = async () => {
                try {
                    const response = await fetch('@Url.Page("prices")');
                    const result = await response.json();

                    for(let i = 0 ; i < result.prices.length && i<maxDataPoints; i++) {
                        var price = result.prices[i].close_price;
                        var timestamp = result.prices[i].timestamp;
                        data.push(price);
                        labels.push(timestamp);

                        console.log(price);
                    }

                } catch (error) {
                    console.error('Error fetching coin data:', error);
                }
            };
            init();

            document.getElementById("lineChart").addEventListener("mouseenter", function(  ) {
                isMouseOnChart=true;
                document.getElementById('myHoverPrice').style.visibility = 'visible';
                updateChart();
            });
            document.getElementById("lineChart").addEventListener("mouseout", function(  ) {
                isMouseOnChart=false;
                document.getElementById('myHoverPrice').style.visibility = 'hidden';
                updateChart();
            });

            canvas.addEventListener('wheel', (event) => {
                event.preventDefault(); 
                zoomOutAxisY += event.deltaY*0.0005;
                if (zoomOutAxisY <0 ) zoomOutAxisY = 0;

                updateChart();
            });

            canvas.addEventListener('mousemove', (event) => {
                const rect = canvas.getBoundingClientRect();
                lastMouseY = event.clientY - rect.top;
                lastMouseX = event.clientX - rect.left;
                document.getElementById('myHoverPrice').style.top = `${event.clientY - rect.top}px`
                document.getElementById('myHoverPrice').style.left = `${rect.left + rect.width + 4}px`
                updateChart();
            });

            // Erik la till en klick funktion också
            canvas.addEventListener('click', () => {
                document.getElementById('price').value = myPrice
            });

            function drawMouseTooltip() {
                if (!isMouseOnChart) return 0;
                ctx.beginPath();
                ctx.moveTo(0, lastMouseY);
                ctx.lineTo(canvas.width, lastMouseY);
                ctx.strokeStyle = 'white';
                ctx.stroke();
                
                ctx.textAlign = 'center';
                ctx.font = '23px Arial';
                ctx.fillStyle = 'white';
                let mousePrice = getPriceFromPixelY(lastMouseY);
                let verticalOffset = -40;
                let posY = getPixelFromPrice(getPriceFromPixelX(lastMouseX));

                ctx.beginPath();
                ctx.moveTo(lastMouseX, posY);
                ctx.lineTo(lastMouseX, posY+verticalOffset);
                ctx.strokeStyle = 'white';
                ctx.stroke();

                myPrice = Number(mousePrice).toFixed(2)
                ctx.fillText(myPrice, lastMouseX, posY+verticalOffset);



                document.getElementById('myHoverPrice').innerText = myPrice
            }

            function getPriceFromPixelX(pixelX) {
                var i = Math.floor(pixelX*(maxDataPoints/graphWidth));
                console.log( i);
                return data[i];
            }
            /*
             * översätter från en viss pixelkoordinat pixelY till ett pris som stämmer med den pixeln 
             */
            function getPriceFromPixelY(pixelY) {
                var graphRange = graphMaxY-graphMinY;
                var ratio = 1-pixelY/height
                return ratio*graphRange+graphMinY;
            }

             /*
             * översätter från ett pris price till en pixelkoordinat som stämmer med det priset
             */
            function getPixelFromPrice(price) {
                var graphRange = graphMaxY-graphMinY;
                var ratio = (price-graphMinY)/graphRange;
                return  height - ratio*height;
            }

             /*
             * uppdaterar höjden på grafjäveln så att den alltid rimmer priset som finns i dat.
             */
            function updateGraphYRange() {
                let maxValue = Math.max(...data);
                let minValue = Math.min(...data);
                let priceRange = maxValue-minValue;
                let graphExtend = priceRange*Math.pow(zoomOutAxisY, 4);


                graphMinY = minValue-graphExtend;
                graphMaxY = maxValue+graphExtend;
            }

            const fetchCoinData = async () => {
                try {
                    const response = await fetch('@Url.Page("latestprice")');
                    const result = await response.json();
                    currentPrice = result.price.close_price;
                    var timestamp = result.price.timestamp;

                    // Update labels and data
                    if (labels.length >= maxDataPoints) {
                        labels.shift();
                        data.shift();
                    }

                    document.getElementById("priceText").innerText = currentPrice;
                    data.push(currentPrice);
                    labels.push(timestamp);
                    updateChart();   
                } catch (error) {
                    console.error('Error fetching coin data:', error);
                }
            };

            const updateChart = () => {
                // Clear canvas
                updateGraphYRange();
                ctx.clearRect(0, 0, width, height);


                

                // Create the gradient for the fill
                const gradient = ctx.createLinearGradient(0, 0, 0, height);
                //gradient.addColorStop(0, 'rgba(25, 98, 139, 0.5)');
                gradient.addColorStop(0, 'rgba(41, 124, 179, 0.9)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0.7  )');
                //gradient.addColorStop(1, 'rgba(13, 39, 56, 1.0  )');


                function drawGraphValues() {
                    ctx.beginPath();
                    ctx.moveTo(0, getPixelFromPrice(data[0]) );
                    data.forEach((value, index) => {
                        const x = (graphWidth / maxDataPoints) * index+1;
                        const y = getPixelFromPrice(value);
                        ctx.lineTo(x, y);
                    });
                }
                
                // Draw the gradient fill
                drawGraphValues()
                ctx.lineWidth = 3 //thicker graph line
                ctx.lineTo((graphWidth / maxDataPoints)*(labels.length), height);
                ctx.lineTo(0, height);
                ctx.closePath();
                ctx.fillStyle = gradient;
                ctx.fill();

                
                // Draw the line on top of the gradient fill
                drawGraphValues()
                ctx.strokeStyle = 'rgba(255, 255, 255, 1)';
                ctx.stroke();
                

                // Draw the labels
                ctx.fillStyle = '#000';
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'white';
                let minutesAgo = Math.floor(labels.length/60);
                labels.forEach((label, index) => {
                    if (index % 60 === 0 || index === labels.length - 1) { // Display label every 60 seconds or at the end
                        const x = (graphWidth / (labels.length - 1)) * index;
                        const y = height - 20;
                        if (minutesAgo === 0) {
                            ctx.textAlign = 'right';
                            ctx.fillText("now", x, y);
                        }
                        else if (minutesAgo === 1) {
                            ctx.textAlign = 'center';
                            ctx.fillText("1 minute ago", x, y);
                        }
                        else if (minutesAgo === Math.floor(labels.length/60)) {
                            ctx.textAlign = 'left';
                            ctx.fillText(minutesAgo+" minutes ago", x, y);
                        }
                        else {
                            ctx.textAlign = 'center';
                            ctx.fillText(minutesAgo+" minutes ago", x, y);
                        }
                        minutesAgo --;

                        ctx.beginPath();
                        ctx.moveTo(x, height);
                        ctx.lineTo(x, height-10);
                        ctx.stroke();
                    }
                });

                //draw lines and text on mouse
                drawMouseTooltip();


                  //upddate market order price
                 if (document.getElementById('marketType').value === "market") {
                    price.disabled = true
                    document.getElementById('price').value = currentPrice;
                } else {
                    price.disabled = false
                }
                };
            // Fetch new data every second
            setInterval(fetchCoinData, 1000);
        });




        const buySellButtons = document.querySelectorAll('.buy-sell-btn')
        const amount = document.getElementById('amount')
        const price = document.getElementById('price')
        const leverage = document.getElementById('leverage')
        const orderValue = document.getElementById('orderValue')
        const marketType = document.getElementById('marketType')

        function urlBuilder(base, parmas) {
            let buildUrl = function (base, key, value) {
                let sep = (base.indexOf('?') > -1) ? '&' : '?';
                return base + sep + key + '=' + value;
            }
            for (var property in parmas) {
                if (parmas.hasOwnProperty(property)) {
                    base = buildUrl(base, property, parmas[property]);
                }
            }

            return base;
        }

        function changeTotalValue() {
            let p = parseFloat(price.value)
            let a = parseFloat(amount.value)
            let l = parseInt(leverage.value)
            if (Number.isFinite(p) && Number.isFinite(a) && Number.isInteger(l)) {
                document.getElementById('total-value').innerHTML = `: ${(a / p) * l} &#8383;`
            }
        }

        price.addEventListener('change', changeTotalValue)
        amount.addEventListener('input', changeTotalValue)
        leverage.addEventListener('change', changeTotalValue)

        buySellButtons.forEach((element) => {
            element.addEventListener('click', (e) => {

                e.preventDefault();

                let side = e.target.innerText.toLowerCase()

                console.log(side)

                $.getJSON(urlBuilder("Position/OpenPosition", { amount: parseFloat(amount.value), price: parseFloat(price.value), leverage: parseInt(leverage.value), side: side, type: marketType.value }), function (data) {
                    console.log(data)
                })
            })
        })

    </script>
}