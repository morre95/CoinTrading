@page
@model CoinTrading.Pages.GameModel
@{
    ViewData["Title"] = "Game";
}
<style>
    body, html {
        margin: 0;
        padding: 0;
    }
</style>

<div class="text-center">
    <h1 id="priceText">Live Coin Price</h1>
    <canvas id="lineChart" width="1200" height="800" style="border:1px solid #000; background-color: #0D2738;"></canvas>
</div>

@section Scripts {
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            const canvas = document.getElementById('lineChart');
            const ctx = canvas.getContext('2d');

            const width = canvas.width;
            const height = canvas.height;
            const graphWidth = width;
            const graphHeight = height;

            let labels = [];
            let data = [];

            const maxDataPoints = 300; // Assuming 1 data point per second for 5 minutes

            const fetchCoinData = async () => {
                try {
                    const response = await fetch('https://localhost:7006/latestprice'); 
                    const result = await response.json();
                    currentPrice = result.price.close_price;
                    const timestamp = new Date().toLocaleTimeString();

                    // Update labels and data
                    if (labels.length >= maxDataPoints) {
                        labels.shift();
                        data.shift();
                    }
                    var element = document.getElementById("priceText");

                    element.innerText = currentPrice;
                    data.push(currentPrice);
                    labels.push(timestamp);
                    updateChart();
                } catch (error) {
                    console.error('Error fetching coin data:', error);
                }
            };

            const updateChart = () => {
                // Clear canvas
                ctx.clearRect(0, 0, width, height);

                // Draw the X and Y axis
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, height);
                ctx.lineTo(width, height);
                ctx.stroke();
                

                // Calculate the max value to scale the graph
                const maxValue = Math.max(...data);
                const minValue = Math.min(...data);

                const shiftY = minValue - (maxValue - minValue) * 0.3;
                const scaleY = graphHeight / ((maxValue - minValue)*1.5);

                // Create the gradient for the fill
                const gradient = ctx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, 'rgba(25, 98, 139, 0.7)');
                gradient.addColorStop(1, 'rgba(25, 98, 139, 0.0)');

                // Draw the data points and lines with gradient fill
                ctx.beginPath();
                ctx.moveTo(0, height - (data[0]-shiftY) * scaleY);
                data.forEach((value, index) => {
                    const x = (graphWidth / (labels.length - 1)) * index;
                    const y = height - (value-shiftY) * scaleY;
                    ctx.lineTo(x, y);
                });
                ctx.lineTo(width, height);
                ctx.lineTo(0, height);
                ctx.closePath();
                ctx.fillStyle = gradient;
                ctx.fill();

                // Draw the line on top of the gradient fill
                ctx.beginPath();
                ctx.moveTo(0, height - (data[0]-shiftY) * scaleY);
                data.forEach((value, index) => {
                    const x = (graphWidth / (labels.length - 1)) * index;
                    const y = height - (value-shiftY) * scaleY;
                    ctx.lineTo(x, y);
                });
                ctx.strokeStyle = 'rgba(255, 255, 255, 1)';
                ctx.stroke();

                // Draw the labels
                ctx.fillStyle = '#000';
                ctx.textAlign = 'center';
                labels.forEach((label, index) => {
                    if (index % 60 === 0 || index === labels.length - 1) { // Display label every 60 seconds or at the end
                        const x = (graphWidth / (labels.length - 1)) * index;
                        const y = height + 20;
                        ctx.fillText(label, x, y);
                    }
                });
            };

            // Fetch new data every second
            setInterval(fetchCoinData, 1000);
        });
    </script>
}