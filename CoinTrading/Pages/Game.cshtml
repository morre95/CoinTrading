@page
@model CoinTrading.Pages.GameModel
@{
    ViewData["Title"] = "Game";
}

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Coin Price</title>
    
    <style>
        .trade-form {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 20px;
        }

            .trade-form .form-group {
                margin: 0 10px;
                flex: 1;
            }

            .trade-form .buysell-buttons {
                display: flex;
            }

                .trade-form .buysell-buttons .btn {
                    margin: 0 5px;
                    flex: 1;
                }
    </style>
</head>
<body>
    <div class="text-center">
        <h1 class="display-4">Live Coin Price</h1>
        <canvas id="lineChart" width="800" height="500" style="border:1px solid #000;"></canvas>

        <div class="trade-form">
            <div class="form-group">
                <label for="marketType">Order Type</label>
                <select id="marketType" class="form-control">
                    <option value="market">Market</option>
                    <option value="limit">Limit</option>
                </select>
            </div>
            <div class="form-group">
                <label for="leverage">Leverage</label>
                <input type="text" id="leverage" class="form-control" placeholder="Leverage">
            </div>
            <div class="form-group">
                <label for="price">Price</label>
                <input type="text" id="price" class="form-control" placeholder="Price">
            </div>
            <div class="form-group">
                <label for="amount">Amount</label>
                <input type="text" id="amount" class="form-control" placeholder="Amount">
            </div>
            <div class="buysell-buttons">
                <button class="btn btn-primary">Buy</button>
                <button class="btn btn-danger">Sell</button>
            </div>
        </div>
    </div>

</body>
</html>




@section Scripts {
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            const canvas = document.getElementById('lineChart');
            const ctx = canvas.getContext('2d');

            const padding = 50;
            const width = canvas.width;
            const height = canvas.height;
            const graphWidth = width - padding * 2;
            const graphHeight = height - padding * 2;

            let labels = [];
            let data = [];

            const maxDataPoints = 300; // Assuming 1 data point per second for 5 minutes

            const fetchCoinData = async () => {
                try {
                    // Fetch the latest coin price data from an API

                    const timestamp = new Date().toLocaleTimeString();

                    // Update labels and data
                    if (labels.length >= maxDataPoints) {
                        labels.shift();
                        data.shift();
                    }
                    labels.push(timestamp);
                    data.push(Math.random());

                    updateChart();
                } catch (error) {
                    console.error('Error fetching coin data:', error);
                }
            };

            const updateChart = () => {
                // Clear canvas
                ctx.clearRect(0, 0, width, height);

                // Draw the X and Y axis
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, height - padding);
                ctx.lineTo(width - padding, height - padding);
                ctx.stroke();

                // Calculate the max value to scale the graph
                const maxValue = Math.max(...data);
                const scaleY = graphHeight / maxValue;

                // Create the gradient for the fill
                const gradient = ctx.createLinearGradient(0, padding, 0, height - padding);
                gradient.addColorStop(0, 'rgba(75, 192, 192, 0.5)');
                gradient.addColorStop(1, 'rgba(75, 192, 192, 0)');

                // Draw the data points and lines with gradient fill
                ctx.beginPath();
                ctx.moveTo(padding, height - padding - data[0] * scaleY);
                data.forEach((value, index) => {
                    const x = padding + (graphWidth / (labels.length - 1)) * index;
                    const y = height - padding - value * scaleY;
                    ctx.lineTo(x, y);
                });
                ctx.lineTo(width - padding, height - padding);
                ctx.lineTo(padding, height - padding);
                ctx.closePath();
                ctx.fillStyle = gradient;
                ctx.fill();

                // Draw the line on top of the gradient fill
                ctx.beginPath();
                ctx.moveTo(padding, height - padding - data[0] * scaleY);
                data.forEach((value, index) => {
                    const x = padding + (graphWidth / (labels.length - 1)) * index;
                    const y = height - padding - value * scaleY;
                    ctx.lineTo(x, y);
                });
                ctx.strokeStyle = 'rgba(75, 192, 192, 1)';
                ctx.stroke();

                // Draw the labels
                ctx.fillStyle = '#000';
                ctx.textAlign = 'center';
                labels.forEach((label, index) => {
                    if (index % 60 === 0 || index === labels.length - 1) { // Display label every 60 seconds or at the end
                        const x = padding + (graphWidth / (labels.length - 1)) * index;
                        const y = height - padding + 20;
                        ctx.fillText(label, x, y);
                    }
                });
            };

            // Fetch new data every second
            setInterval(fetchCoinData, 1000);
        });
    </script>
}