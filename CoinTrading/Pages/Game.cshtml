@page
@model CoinTrading.Pages.GameModel
@{
    ViewData["Title"] = "Live Coin Price";
}

<style>
    .trade-form {
        display: flex;
        align-items: flex-end;
        justify-content: center;
        margin-top: 20px;
        padding-block-start: 100px;
        padding-block-end: 100px;
    }

    .trade-form .form-group {
        margin: 0 10px;
        flex: 1;
    }


    .trade-form .form-group input,
    .trade-form .form-group select {
        width: 100%; /* Modifierad till 100% för att ta upp hela bredden av .form-group */
        margin: auto;
    }

    .trade-form .buysell-buttons {
        display: flex;
        align-items: flex-end;
    }

    #myHoverPrice {
        position: absolute;
    }
</style>
<div class="text-center">
    <h1 id="priceText" class="display-4">Live Coin Price</h1>
    <canvas id="lineChart" width="1200" height="800" style="border:1px solid #000; background-color: #0D2738;"></canvas>

    <!-- Eriks ändringar -->
    <div id="myHoverPrice"></div>
    <!-- slut på Eriks ändringar -->
    @if (Model.IsLoegin)
    {
        <div class="trade-form">
            <div class="form-group">
                <label for="marketType">Order Type</label>
                <select id="marketType" name="marketType" class="form-control">
                    <option value="market">Market</option>
                    <option value="limit">Limit</option>
                </select>
            </div>
            <div class="form-group">
                <label for="leverage">Leverage</label>
                <input type="text" id="leverage" name="leverage" class="form-control" placeholder="Leverage">
            </div>
            <div class="form-group">
                <label for="price">Price</label>
                <input type="text" id="price" name="price" class="form-control" placeholder="Price">
            </div>
            <div class="form-group">
                <label for="amount">Amount</label>
                <input type="text" id="amount" name="amount" class="form-control" placeholder="Amount">
                <small id="orderValue"></small>
            </div>
            <div class="buysell-buttons">
                <button class="btn btn-primary" id="buyBtn">Buy</button>
                <button class="btn btn-danger">Sell</button>
            </div>
        </div>
    }
    else
    {
        <div><a href="./Login">Login</a></div>
    }

</div>

@section Scripts {
    <script>

        document.addEventListener("DOMContentLoaded", function () {
            const canvas = document.getElementById('lineChart');
            const ctx = canvas.getContext('2d');



            const width = canvas.width;
            const height = canvas.height;
            const graphWidth = width;
            const graphHeight = height;
            let lastMouseY = 0;
            let currentPrice = 0;
            let labels = [];
            let data = [];
            let maxValue = 1;
            let minValue = 0;

            // Eriks ändringar
            let myPrice = 0;
            // Slut på Eriks ändringar

            const maxDataPoints = 300; // Assuming 1 data point per second for 5 minutes

            canvas.addEventListener('mousemove', (event) => {
                // Get mouse position relative to the canvas
                const rect = canvas.getBoundingClientRect();
                const mouseY = event.clientY - rect.top;
                lastMouseY = mouseY;
                // Redraw the graph and the horizontal line
                updateChart();



                // Eriks Ändringar
                document.getElementById('myHoverPrice').style.top = `${event.clientY - 20}px`
                document.getElementById('myHoverPrice').style.left = `${rect.left + rect.width + 4}px`
                document.getElementById('myHoverPrice').innerText = myPrice
                // Slut på Eriks ändringar
            });

            // Erik la till en klick funktion också
            canvas.addEventListener('click', () => {
                document.getElementById('price').value = myPrice
            });

            function drawHorizontalLine() {
                ctx.beginPath();
                ctx.moveTo(0, lastMouseY);
                ctx.lineTo(canvas.width, lastMouseY);
                ctx.strokeStyle = 'white';
                ctx.stroke();
                
                ctx.textAlign = 'right';
                ctx.font = '21px Arial';
                ctx.fillStyle = 'white';
                let mousePrice = maxValue-(maxValue-minValue)*(lastMouseY/(height*1.5))-(maxValue-minValue)*0.3
                //ctx.fillText(Number(mousePrice).toFixed(2)+" (fel)", width, lastMouseY);



                // Eriks ändringar
                myPrice = Number(mousePrice).toFixed(2)
                // Slut på Eriks ändringar
            }

            const fetchCoinData = async () => {
                try {
                    const response = await fetch('@Url.Page("latestprice")');
                    const result = await response.json();
                    currentPrice = result.price.close_price;
                    const timestamp = new Date().toLocaleTimeString();

                    // Update labels and data
                    if (labels.length >= maxDataPoints) {
                        labels.shift();
                        data.shift();
                    }
                    var element = document.getElementById("priceText");

                    element.innerText = currentPrice;
                    data.push(currentPrice);
                    labels.push(timestamp);
                    updateChart();
                } catch (error) {
                    console.error('Error fetching coin data:', error);
                }
            };

            const updateChart = () => {
                // Clear canvas
                ctx.clearRect(0, 0, width, height);

                // Draw the X and Y axis
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, height);
                ctx.lineTo(width, height);
                ctx.stroke();
                

                // Calculate the max value to scale the graph
                maxValue = Math.max(...data);
                minValue = Math.min(...data);

                const shiftY = minValue - (maxValue - minValue) * 0.3;
                const scaleY = graphHeight / ((maxValue - minValue)*1.5);

                // Create the gradient for the fill
                const gradient = ctx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, 'rgba(25, 98, 139, 0.7)');
                gradient.addColorStop(1, 'rgba(25, 98, 139, 0.0)');

                // Draw the data points and lines with gradient fill
                ctx.beginPath();
                ctx.moveTo(0, height - (data[0]-shiftY) * scaleY);
                data.forEach((value, index) => {
                    const x = (graphWidth / (labels.length - 1)) * index;
                    const y = height - (value-shiftY) * scaleY;
                    ctx.lineTo(x, y);
                });
                ctx.lineTo(width, height);
                ctx.lineTo(0, height);
                ctx.closePath();
                ctx.fillStyle = gradient;
                ctx.fill();

                // Draw the line on top of the gradient fill
                ctx.beginPath();
                ctx.moveTo(0, height - (data[0]-shiftY) * scaleY);
                data.forEach((value, index) => {
                    const x = (graphWidth / (labels.length - 1)) * index;
                    const y = height - (value-shiftY) * scaleY;
                    ctx.lineTo(x, y);
                });
                ctx.strokeStyle = 'rgba(255, 255, 255, 1)';
                ctx.stroke();

                // Draw the labels
                ctx.fillStyle = '#000';
                ctx.textAlign = 'center';
                labels.forEach((label, index) => {
                    if (index % 60 === 0 || index === labels.length - 1) { // Display label every 60 seconds or at the end
                        const x = (graphWidth / (labels.length - 1)) * index;
                        const y = height + 20;
                        ctx.fillText(label, x, y);
                    }
                });

                //draw mouse line
                drawHorizontalLine();
            };

            // Fetch new data every second
            setInterval(fetchCoinData, 1000);
        });




        const amount = document.getElementById('amount')
        const price = document.getElementById('price')
        const leverage = document.getElementById('leverage')
        const orderValue = document.getElementById('orderValue')

        function urlBuilder(base, parmas) {
            let buildUrl = function (base, key, value) {
                let sep = (base.indexOf('?') > -1) ? '&' : '?';
                return base + sep + key + '=' + value;
            }
            for (var property in parmas) {
                if (parmas.hasOwnProperty(property)) {
                    base = buildUrl(base, property, parmas[property]);
                }
            }

            return base;
        }

        document.getElementById('buyBtn').addEventListener('click', (e) => {

            e.preventDefault();

            $.getJSON(urlBuilder("Position/OpenPosition", { amount: amount.value, price: price.value, leverage: leverage.value, side: 'buy' }), function (data) {
                console.log(data)
            });
        })
        
    </script>
}